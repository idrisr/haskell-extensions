\documentclass[openany, 12pt]{book}
\input{preamble}
\title{Haskell Extensions}
\author{Idris}
\date{March 2025}

\usepackage{tocloft} % Package for customizing TOC
\usepackage{supertabular} % Package for customizing TOC
\renewcommand{\thepart}{\arabic{part}}
\renewcommand{\thechapter}{\thepart.\arabic{chapter}} % Chapter numbers preceded by part number
\setlength{\cftchapnumwidth}{2.5em} % Space after chapter number
\setlength{\cftchapindent}{1em} % Indent chapter entries (adjust as needed)
\setlength{\cftpartindent}{0em} % Keep part entries flush left (default, explicitly set)
\counterwithin{chapter}{part}

\begin{document}
% \maketitle{}
\tableofcontents

\frontmatter{}
\chapter{Preface}
The haskell language extensions are a tough nut to crack. This document is my
attempt to get stronger on them, contributing in increments whenever I come
across one I need to learn more deeply---there are a lot I need to learn more
deeply.

This document is structured the same was as the online documentation for the
language extensions available here
\href{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html}{users guide}

\mainmatter{}
\part{Introduction}
\chapter{Controlling editions and extensions}
\href{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/control.html}{extensions}

GHC supports multiple language editions:

\begin{multicols}{4}
	\begin{enumerate}[label = {(\arabic*)}]
		\item Haskell98
		\item Haskell2010
		\item GHC2021
		\item GHC2024
	\end{enumerate}
\end{multicols}

Each language edition consists of a collection of language extensions, and there
are many other language extensions not currently part of a language edition but
that can be enabled explicitly.

\chapter{Overview of all language extensions}


\begin{longtable}{ll}
	\toprule
	Extension                  & Description                                                                \\
	\midrule
	\endfirsthead

	\toprule
	Extension                  & Description                                                                \\
	\midrule
	\endhead

	\bottomrule
	\endfoot

	AllowAmbiguousTypes        & Allow ambiguous types, and type inference engine to infer them.            \\
	ApplicativeDo              & Allow do-notation statements to be desugared via Applicative.              \\
	Arrows                     & Allow arrow notation (eg proc)                                             \\
	BangPatterns               & Allow bang pattern syntax.                                                 \\
	BinaryLiterals             & Allow binary literal syntax.                                               \\
	BlockArguments             & Allow do blocks and other constructs as function arguments.                \\
	CApiFFI                    & Allow foreign imports to be declared with the capi calling convention.     \\
	ConstrainedClassMethods    & Allow class methods to have non-empty contexts.                            \\
	ConstraintKinds            & Allow constraints to be used as types of kind Constraint.                  \\
	CPP                        & Resolve C preprocessor directives.                                         \\
	CUSKs                      & Detect complete user-supplied kind signatures.                             \\
	DataKinds                  & Allow use of data constructors in types.                                   \\
	DatatypeContexts           & Allow contexts on data types.                                              \\
	DeepSubsumption            & Use GHC's deep subsumption checking.                                       \\
	DefaultSignatures          & Allow default signatures for typeclass methods.                            \\
	DeriveAnyClass             & Allow deriving syntax to be used for any class.                            \\
	DeriveDataTypeable         & Allow deriving for the Data class.                                         \\
	DeriveFoldable             & Allow deriving for the Foldable class.                                     \\
	DeriveFunctor              & Allow deriving for the Functor class.                                      \\
	DeriveGeneric              & Allow deriving of Generic instances.                                       \\
	DeriveLift                 & Allow deriving for the Lift class                                          \\
	DeriveTraversable          & Allow deriving for the Traversable class.                                  \\
	DerivingStrategies         & Allow use of instance deriving strategies.                                 \\
	DerivingVia                & Allow deriving instances via types of the same runtime representation.     \\
	DisambiguateRecordFields   & Automatically disambiguate some record field references.                   \\
	DoAndIfThenElse            & Allow semicolons in if expressions.                                        \\
	DuplicateRecordFields      & Allow definition of record types with identically-named fields.            \\
	EmptyCase                  & Allow case expressions with no alternatives.                               \\
	EmptyDataDecls             & Allow definition of empty data types.                                      \\
	EmptyDataDeriving          & Allow deriving instances of standard type classes for empty data types.    \\
	ExistentialQuantification  & Allow existentially quantified type variables in types.                    \\
	ExplicitForAll             & Allow explicit universal quantification.                                   \\
	ExplicitLevelImports       & Allow explicit level imports in Template Haskell.                          \\
	ExplicitNamespaces         & keyword type to specify the namespace of entries in imports and exports.   \\
	ExtendedDefaultRules       & Use GHCi's extended default rules in a normal module.                      \\
	ExtendedLiterals           & Allow numeric literal postfix syntax for unboxed integers.                 \\
	FieldSelectors             & Make record field selector functions visible in expressions.               \\
	FlexibleContexts           & Remove some restrictions on class contexts                                 \\
	FlexibleInstances          & Allow instance heads to mention arbitrary nested types.                    \\
	ForeignFunctionInterface   & Allow foreign function interface syntax.                                   \\
	FunctionalDependencies     & Allow functional dependencies to be given on typeclass declarations.       \\
	GADTs                      & Allow definition of generalised algebraic data types.                      \\
	GADTSyntax                 & Allow generalised algebraic data type syntax.                              \\
	GeneralisedNewtypeDeriving & Allow instances to be derived via newtype deriving.                        \\
	GHC2021                    & Use GHC’s set of default language extensions from 2021                     \\
	GHC2024                    & Use GHC’s set of default language extensions from 2024                     \\
	GHCForeignImportPrim       & Allow prim calling convention. Intended for internal use only.             \\
	Haskell2010                & Use the Haskell 2010 language edition.                                     \\
	Haskell98                  & Use the Haskell 98 language edition.                                       \\
	HexFloatLiterals           & Allow hexadecimal floating-point literal syntax.                           \\
	ImplicitParams             & Allow implicit parameter constraints.                                      \\
	ImplicitPrelude            & Implicitly import Prelude.                                                 \\
	ImplicitStagePersistence   & identifiers to be used at different levels from where they are defined.    \\
	ImportQualifiedPost        & Allows the syntax import M qualified                                       \\
	ImpredicativeTypes         & Allow impredicative types.                                                 \\
	IncoherentInstances        & Allow definitions of instances that may result in incoherence.             \\
	InstanceSigs               & Allow type signatures to be written for instance methods.                  \\
	InterruptibleFFI           & Allow interruptible FFI imports.                                           \\
	KindSignatures             & Allow kind signatures to be given for types.                               \\
	LambdaCase                 & Allow case expressions.                                                    \\
	LexicalNegation            & whitespace to determine whether the minus sign is negation or subtraction  \\
	LiberalTypeSynonyms        & Relax many of Haskell 98's rules on type synonym definitions.              \\
	LinearTypes                & Allow writing of linear arrow types. Implies MonoLocalBinds.               \\
	ListTuplePuns              & Enable punning for list, tuple and sum types.                              \\
	MagicHash                  & Allow \# as a postfix modifier on identifiers.                             \\
	MonadComprehensions        & Allow list comprehension syntax to be used at monads other than List.      \\
	MonoLocalBinds             & Do not generalise types of local bindings.                                 \\
	MonomorphismRestriction    & Apply the Haskell 2010 monomorphism restriction.                           \\
	MultilineStrings           & Enable multiline string literals.                                          \\
	MultiParamTypeClasses      & Enable multi-parameter type classes.                                       \\
	MultiWayIf                 & Allow multi-way if-expressions.                                            \\
	NamedDefaults              & Enable default declarations with explicitly named class.                   \\
	NamedFieldPuns             & Allow record field punning syntax.                                         \\
	NamedWildCards             & Allow named wildcards in types.                                            \\
	NegativeLiterals           & Allow negative numeric literal syntax.                                     \\
	NondecreasingIndentation   & Allow nested contexts at the same indentation level as enclosing context   \\
	NPlusKPatterns             & Allow use of n+k patterns.                                                 \\
	NullaryTypeClasses         & Deprecated, does nothing.                                                  \\
	NumDecimals                & Allow use of scientific notation syntax for integer literals.              \\
	NumericUnderscores         & Allow underscores in numeric literals.                                     \\
	OrPatterns                 & Enable or-patterns.                                                        \\
	OverlappingInstances       & Allow definition of overlapping instances.                                 \\
	OverloadedLabels           & Allow overloaded label syntax.                                             \\
	OverloadedLists            & Desugar list syntax via the IsList class.                                  \\
	OverloadedRecordDot        & Allow . to be used for record field access.                                \\
	OverloadedRecordUpdate     & Allow . syntax in record updates                                           \\
	OverloadedStrings          & Desugar string literals via IsString class.                                \\
	PackageImports             & Allow package-qualified import syntax.                                     \\
	ParallelListComp           & Allow parallel list comprehension syntax.                                  \\
	PartialTypeSignatures      & Allow type signatures to contain wildcards.                                \\
	PatternGuards              & Allow pattern guards syntax.                                               \\
	PatternSynonyms            & Allow definition of pattern synonyms.                                      \\
	PolyKinds                  & Allow kind polymorphism.                                                   \\
	PostfixOperators           & Allow the use of postfix operators.                                        \\
	QualifiedDo                & Allow qualified do-notation desugaring.                                    \\
	QuantifiedConstraints      & Allow forall quantifiers in constraints.                                   \\
	QuasiQuotes                & Allow quasiquotation syntax.                                               \\
	Rank2Types                 & Enable rank-2 types.                                                       \\
	RankNTypes                 & Allow types of rank greater than one.                                      \\
	RebindableSyntax           & Allow rebinding of builtin syntax.                                         \\
	RecordWildCards            & Allow use of record wildcard syntax.                                       \\
	RecursiveDo                & Allow recursive do (e.g. mdo) notation.                                    \\
	RequiredTypeArguments      & Allow use of required type argument syntax in terms.                       \\
	RoleAnnotations            & Allow role annotation syntax.                                              \\
	Safe                       & Enable the Safe Haskell Safe mode.                                         \\
	ScopedTypeVariables        & Lexically scope explicitly-introduced type variables.                      \\
	StandaloneDeriving         & Allow standalone instance deriving declarations.                           \\
	StandaloneKindSignatures   & Allow standalone kind signature declarations.                              \\
	StarIsType                 & Treat * as Data.Kind.Type.                                                 \\
	StaticPointers             & Allow static syntax.                                                       \\
	StrictData                 & Treat datatype fields as strict by default.                                \\
	Strict                     & Make bindings in the current module strict by default.                     \\
	TemplateHaskell            & Allow Template Haskell's splice and quotation syntax.                      \\
	TemplateHaskellQuotes      & Allow Template Haskell's quotation syntax.                                 \\
	TraditionalRecordSyntax    & Allow traditional record syntax (e.g. C {f = x}).                          \\
	TransformListComp          & Allow generalised list comprehension syntax.                               \\
	Trustworthy                & Enable the Safe Haskell Trustworthy mode.                                  \\
	TupleSections              & Allow use of tuple section synxtax.                                        \\
	TypeAbstractions           & Allow type abstraction syntax in patterns and type variable binders.       \\
	TypeApplications           & Allow type application syntax in terms and types.                          \\
	TypeData                   & Allow type data declarations.                                              \\
	TypeFamilies               & Allow definition of type families.                                         \\
	TypeFamilyDependencies     & Allow injectivity annotations on type families.                            \\
	TypeInType                 & Deprecated. Enable kind polymorphism and datatype promotion.               \\
	TypeOperators              & Allow type constructors to be given operator names.                        \\
	TypeSynonymInstances       & Allow type synonyms to be mentioned in instance heads.                     \\
	UnboxedSums                & Allow the use of unboxed sum syntax.                                       \\
	UnboxedTuples              & Allow the use of unboxed tuple syntax.                                     \\
	UndecidableInstances       & Allow definition of instances which may make solving undecidable.          \\
	UndecidableSuperClasses    & superclass constraints, including those that may result in non-termination \\
	UnicodeSyntax              & Enable unicode syntax.                                                     \\
	UnliftedDatatypes          & Allow the definition of unlifted data types.                               \\
	UnliftedFFITypes           & Allow the types of foreign imports to contain certain unlifted types.      \\
	UnliftedNewtypes           & Allow definition of unlifted newtypes.                                     \\
	Unsafe                     & Enable Safe Haskell Unsafe mode.                                           \\
	ViewPatterns               & Allow view pattern syntax.                                                 \\
\end{longtable}

\part{Syntax}
\part{Import and export}

\chapter{ImportQualifiedPost}
from
\begin{haskell}{}
import qualified A
import           B
import           C
\end{haskell}

to
\begin{haskell}{}
import A qualified
import B
import C
\end{haskell}


\part{Types}


\setcounter{chapter}{7}
\chapter{GADTSyntax---Declaring data types with explicit constructor signatures}
Instead of
\begin{haskell}{}
data Maybe a = Nothing | Just a
\end{haskell}

You can do
\begin{haskell}{}
data Maybe a where
    Nothing :: Maybe a
    Just    :: a -> Maybe a
\end{haskell}

\chapter{GADTs---Generalised Algebraic Data Types}
Generalise ordinary algebraic data types by allowing constructors to have richer
return types.

\begin{haskell}{}
data Term a where
    Lit    :: Int -> Term Int
    Succ   :: Term Int -> Term Int
    IsZero :: Term Int -> Term Bool
    If     :: Term Bool -> Term a -> Term a -> Term a
    Pair   :: Term a -> Term b -> Term (a,b)
\end{haskell}

\begin{figure}[H]
	\begin{center}
		\begin{forest}
			[GADT
					[Constraint Kinds]
					[Data Kinds]
			]
		\end{forest}
	\end{center}
	\caption{GADTs become most useful with Constraint and Data Kinds}
\end{figure}


\setcounter{chapter}{9}
\chapter{TypeFamilies---Type families}
Functions are to values what type families are to types. They provide a way to
specify how to map one type to another.

\begin{definition}{closed}{}
	A closed type family is defined all in one place and cannot be extended.
\end{definition}

\begin{definition}{open}{}
	Unlike closed type families, which are a black-box, open type families can be extended.
\end{definition}


\chapter{DataKinds---Datatype promotion}
\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/data_kinds.html}

Way to introduce new symbols into the Kind system.

\setcounter{chapter}{13}
\chapter{PolyKinds---Kind Polymorphism}
from
\begin{haskell}{}
class Typeable (t :: *) where
    typeOf :: t -> TypeRep

class Typeable1 (t :: * -> *) where
    typeOf1 :: t a -> TypeRep

class Typeable2 (t :: * -> * -> *) where
    typeOf2 :: t a b -> TypeRep
\end{haskell}

to
\begin{haskell}{}
{-# LANGUAGE PolyKinds #-}
data Proxy t = Proxy

\begin{haskell}{}
	data App f a = MkApp (f a)
\end{haskell}

Without polykinds, the kind of \hask{App} is \hask{Type -> Type}.

With polykinds, the kind of \hask{App} is \hask{Type -> Type}.

\begin{center}
	\begin{tabular}{ll}
		\toprule
		\hask{App}                                                & \hask{f}                      \\
		\midrule
		\hask{(Type -> Type) -> Type -> Type}                     & \hask{Type -> Type}           \\
		\hask{((Type -> Type) -> Type) -> (Type -> Type) -> Type} & \hask{(Type -> Type) -> Type} \\
		\bottomrule
	\end{tabular}
\end{center}

In the end all that matters is that \hask{f a} is fully saturated.

\setcounter{chapter}{16}
\chapter{TypeApplications---Visible type application}

\setcounter{chapter}{19}
\chapter{RankNTypes---Arbitrary-rank polymorphism}


\part{Records}

\setcounter{chapter}{6}
\chapter{NamedFieldPuns---Record puns}
\begin{haskell}{}
data C = C {a :: Int}
f (C {a = a}) = a
\end{haskell}
becomes

\begin{haskell}{}
f (C {a}) = a
\end{haskell}

\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/record_puns.html}

\chapter{RecordWildCards---RecordWildCards}
\begin{haskell}{}
data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
f (C {a = 1, b = b, c = c, d = d}) = b + c + d
\end{haskell}
becomes

\begin{haskell}{}
f (C {a = 1, ..}) = b + c + d
\end{haskell}
\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/record_wildcards.html}

Permits a “..” in a record pattern, where each elided field \hask{f} is replaced by the
pattern \hask{f = f}.


\part{Deriving mechanism}
\setcounter{chapter}{4}
\chapter{GeneralisedNewtypeDeriving---Generalised derived instances for newtypes}

\setcounter{chapter}{7}
\chapter{DerivingVia---Deriving via}

\part{Patterns}
\part{Class and instances declarations}

\setcounter{chapter}{6}
\chapter{Functional dependencies}
\begin{alist}
	\item used to constrain the parameters of type classes.
	\item let you state that in a multi-parameter type class
	\item one of the parameters can be determined from the others
	\item so that the parameter determined by the others can, for example,
	\item be the return type but none of the argument types of some of the methods.
	\item one of two mechansism for type-level functions. the other is type
	families.
\end{alist}

\begin{haskell}{}
--type level function
class And b1 b2 b | b 1 b 2 -> b where
    and :: b 1 -> b 2 -> b

instance And True True True    where and undefined
instance And True False False  where and undefined
instance And False True False  where and undefined
instance And False False False where and undefined
\end{haskell}

\chapter{Instance declarations and resolution}
\begin{definition}{Instance Declaration}{}
	\begin{haskell}{}
                               context => head
instance (assertion1, ..., assertionn) => class type1 ... typem where ...
    \end{haskell}
\end{definition}

\begin{definition}{Constraint}{}
	The context is made up of constraints.
\end{definition}

\section{FlexibleInstances---Relaxed rules for the instance head}
The pattern  is <class> (Constructor var1 var2). If you have something else, you
need to turn this on

\begin{haskell}{}
instance C (T a b ...)
\end{haskell}

\section{Formal syntax for instance declaration types}
\section{Instance termination rules}
\section{Undecidable instances and loopy superclasses}
\section{Overlapping instances}
Normally two instances can't overlap

\begin{haskell}{}
class Printable a where
    printMe :: a -> IO ()

instance Printable a where
    printMe a = putStrLn "dummy instance"

instance Printable Int where
    printMe a = putStrLn ("I am an Int with value :" ++ show a)
\end{haskell}

\section{Instance signatures: type signatures in instance declarations}

\part{Literals}
\chapter{OverloadedStrings}

\part{Constraints}
\part{Type signatures}
\part{Bindings and generalisation}
\part{Template Haskell}
Allows you to do compile-time meta-programming in Haskell.

\begin{definition}{Meta Programming}{}
	Programs that write programs.
\end{definition}

\begin{definition}{Compile Time Meta Programming}{}
	Programs that write programs at compile time.
\end{definition}

\setcounter{chapter}{2}
\chapter{Viewing Template Haskell Generated Code}
\begin{haskell}{}
-ddump-splices
\end{haskell}

\setcounter{chapter}{6}

\chapter{QuasiQuotes}
Quasi-quotation allows patterns and expressions to be written using
programmer-defined concrete syntax

\begin{definition}{Concrete Syntax}{}
	Concrete syntax refers to the actual textual representation of code, as
	opposed to abstract syntax trees.
	\begin{center}
		\begin{tabular}{ll}
			\toprule
			syntax type & form  \\
			\midrule
			concrete    & text  \\
			abstract    & trees \\
			\bottomrule
		\end{tabular}
	\end{center}
\end{definition}

\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/template_haskell.html#template-haskell-quasi-quotation}

\part{Bang patterns and Strict Haskell}
\part{Parallel and Concurrent}
\part{Unboxed types and primitive operations}
\part{Foreign function interface (FFI)}
\part{Safe Haskell}
\part{Miscellaneous}




\end{document}
