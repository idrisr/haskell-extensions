\documentclass[openany, 12pt]{book}
\input{preamble}
\title{Haskell Extensions}
\author{Idris}
\date{March 2025}

\usepackage{tocloft} % Package for customizing TOC
\renewcommand{\thepart}{\arabic{part}}
\renewcommand{\thechapter}{\thepart.\arabic{chapter}} % Chapter numbers preceded by part number
\setlength{\cftchapnumwidth}{2.5em} % Space after chapter number
\setlength{\cftchapindent}{1em} % Indent chapter entries (adjust as needed)
\setlength{\cftpartindent}{0em} % Keep part entries flush left (default, explicitly set)
\counterwithin{chapter}{part}

\begin{document}
% \maketitle{}
\tableofcontents

\frontmatter
\chapter{Preface}
The haskell language extensions are a tough nut to crack. This document is my
attempt to get stronger on them, contributing in increments whenever I come
across one I need to learn more deeply---there are a lot I need to learn more
deeply.

This document is structured the same was as the online documentation for the
language extensions available here \url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html}.

\mainmatter
\part{Introduction}
\part{Syntax}
\part{Import and export}

\chapter{ImportQualifiedPost}
from
\begin{haskell}{}
import qualified A
import           B
import           C
\end{haskell}

to
\begin{haskell}{}
import A qualified
import B
import C
\end{haskell}


\part{Types}


\setcounter{chapter}{7}
\chapter{GADTSyntax---Declaring data types with explicit constructor signatures}
Instead of
\begin{haskell}{}
data Maybe a = Nothing | Just a
\end{haskell}

You can do
\begin{haskell}{}
data Maybe a where
    Nothing :: Maybe a
    Just    :: a -> Maybe a
\end{haskell}

\chapter{GADTs---Generalised Algebraic Data Types}
Generalise ordinary algebraic data types by allowing constructors to have richer
return types.

\begin{haskell}{}
data Term a where
    Lit    :: Int -> Term Int
    Succ   :: Term Int -> Term Int
    IsZero :: Term Int -> Term Bool
    If     :: Term Bool -> Term a -> Term a -> Term a
    Pair   :: Term a -> Term b -> Term (a,b)
\end{haskell}


\setcounter{chapter}{9}
\chapter{TypeFamilies---Type families}
Functions are to values what type families are to types. They provide a way to
specify how to map one type to another.

\begin{definition}{closed}{}
	A closed type family is defined all in one place and cannot be extended.
\end{definition}

\begin{definition}{open}{}
	Unlike closed type families, which are a black-box, open type families can be extended.
\end{definition}


\chapter{DataKinds---Datatype promotion}
\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/data_kinds.html}

Way to introduce new symbols into the Kind system.

\setcounter{chapter}{13}
\chapter{PolyKinds---Kind Polymorphism}
from
\begin{haskell}{}
class Typeable (t :: *) where
    typeOf :: t -> TypeRep

class Typeable1 (t :: * -> *) where
    typeOf1 :: t a -> TypeRep

class Typeable2 (t :: * -> * -> *) where
    typeOf2 :: t a b -> TypeRep
\end{haskell}

to
\begin{haskell}{}
{-# LANGUAGE PolyKinds #-}
data Proxy t = Proxy

class Typeable (t :: k) where
    typeOf :: Proxy t -> TypeRep
\end{haskell}

\setcounter{chapter}{16}
\chapter{TypeApplications---Visible type application}

\setcounter{chapter}{19}
\chapter{RankNTypes---Arbitrary-rank polymorphism}


\part{Records}

\setcounter{chapter}{6}
\chapter{NamedFieldPuns---Record puns}
\begin{haskell}{}
data C = C {a :: Int}
f (C {a = a}) = a
\end{haskell}
becomes

\begin{haskell}{}
f (C {a}) = a
\end{haskell}

\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/record_puns.html}

\chapter{RecordWildCards---RecordWildCards}
\begin{haskell}{}
data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
f (C {a = 1, b = b, c = c, d = d}) = b + c + d
\end{haskell}
becomes

\begin{haskell}{}
f (C {a = 1, ..}) = b + c + d
\end{haskell}
\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/record_wildcards.html}


\part{Deriving mechanism}
\setcounter{chapter}{5}
\chapter{GeneralisedNewtypeDeriving---Generalised derived instances for newtypes}

\part{Patterns}
\part{Class and instances declarations}

\setcounter{chapter}{6}
\chapter{Functional dependencies}
\begin{alist}
	\item used to constrain the parameters of type classes.
	\item let you state that in a multi-parameter type class
	\item one of the parameters can be determined from the others
	\item so that the parameter determined by the others can, for example,
	\item be the return type but none of the argument types of some of the methods.
	\item one of two mechansism for type-level functions. the other is type
	families.
\end{alist}

\begin{haskell}{}
--type level function
class And b1 b2 b | b 1 b 2 -> b where
    and :: b 1 -> b 2 -> b

instance And True True True    where and undefined
instance And True False False  where and undefined
instance And False True False  where and undefined
instance And False False False where and undefined
\end{haskell}

\part{Literals}
\chapter{OverloadedStrings}

\part{Constraints}
\part{Type signatures}
\part{Bindings and generalisation}
\part{Template Haskell}
Allows you to do compile-time meta-programming in Haskell.

\begin{definition}{Meta Programming}{}
	Programs that write programs.
\end{definition}

\begin{definition}{Compile Time Meta Programming}{}
	Programs that write programs at compile time.
\end{definition}

\setcounter{chapter}{2}
\chapter{Viewing Template Haskell Generated Code}
\begin{haskell}{}
-ddump-splices
\end{haskell}

\setcounter{chapter}{6}

\chapter{QuasiQuotes}
Quasi-quotation allows patterns and expressions to be written using
programmer-defined concrete syntax

\begin{definition}{Concrete Syntax}{}
	Concrete syntax refers to the actual textual representation of code, as
	opposed to abstract syntax trees.
	\begin{center}
		\begin{tabular}{ll}
			\toprule
			syntax type & form  \\
			\midrule
			concrete    & text  \\
			abstract    & trees \\
			\bottomrule
		\end{tabular}
	\end{center}
\end{definition}

\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/template_haskell.html#template-haskell-quasi-quotation}

\part{Bang patterns and Strict Haskell}
\part{Parallel and Concurrent}
\part{Unboxed types and primitive operations}
\part{Foreign function interface (FFI)}
\part{Safe Haskell}
\part{Miscellaneous}




\end{document}
