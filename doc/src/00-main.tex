\documentclass[openany, 12pt]{book}
\input{preamble}
\title{Haskell Extensions}
\author{Idris}
\date{March 2025}

\usepackage{tocloft} % Package for customizing TOC
\renewcommand{\thepart}{\arabic{part}}
\renewcommand{\thechapter}{\thepart.\arabic{chapter}} % Chapter numbers preceded by part number
\setlength{\cftchapnumwidth}{2.5em} % Space after chapter number
\setlength{\cftchapindent}{1em} % Indent chapter entries (adjust as needed)
\setlength{\cftpartindent}{0em} % Keep part entries flush left (default, explicitly set)
\counterwithin{chapter}{part}

\begin{document}
% \maketitle{}
\tableofcontents

\part{Introduction}
\part{Syntax}
\part{Import and export}

\chapter{ImportQualifiedPost}
from
\begin{haskell}{}
import qualified A
import           B
import           C
\end{haskell}

to
\begin{haskell}{}
import A qualified
import B
import C
\end{haskell}


\part{Types}


\setcounter{chapter}{7}
\chapter{GADTSyntax---Declaring data types with explicit constructor signatures}
Instead of
\begin{haskell}{}
data Maybe a = Nothing | Just a
\end{haskell}

You can do
\begin{haskell}{}
data Maybe a where
    Nothing :: Maybe a
    Just    :: a -> Maybe a
\end{haskell}

\chapter{GADTs---Generalised Algebraic Data Types}
Generalise ordinary algebraic data types by allowing constructors to have richer
return types.

\begin{haskell}{}
data Term a where
    Lit    :: Int -> Term Int
    Succ   :: Term Int -> Term Int
    IsZero :: Term Int -> Term Bool
    If     :: Term Bool -> Term a -> Term a -> Term a
    Pair   :: Term a -> Term b -> Term (a,b)
\end{haskell}

\setcounter{chapter}{10}
\chapter{DataKinds---Datatype promotion}
\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/data_kinds.html}

\setcounter{chapter}{16}
\chapter{TypeApplications---Visible type application}

\part{Records}

\setcounter{chapter}{6}
\chapter{NamedFieldPuns---Record puns}
\begin{haskell}{}
data C = C {a :: Int}
f (C {a = a}) = a
\end{haskell}
becomes

\begin{haskell}{}
f (C {a}) = a
\end{haskell}

\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/record_puns.html}

\chapter{RecordWildCards---RecordWildCards}
\begin{haskell}{}
data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
f (C {a = 1, b = b, c = c, d = d}) = b + c + d
\end{haskell}
becomes

\begin{haskell}{}
f (C {a = 1, ..}) = b + c + d
\end{haskell}
\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/record_wildcards.html}


\part{Deriving mechanism}
\setcounter{chapter}{5}
\chapter{GeneralisedNewtypeDeriving---Generalised derived instances for newtypes}

\part{Patterns}
\part{Class and instances declarations}

\setcounter{chapter}{6}
\chapter{Functional dependencies}
\begin{alist}
	\item used to constrain the parameters of type classes.
	\item let you state that in a multi-parameter type class
	\item one of the parameters can be determined from the others
	\item so that the parameter determined by the others can, for example,
	\item be the return type but none of the argument types of some of the methods.
	\item one of two mechansism for type-level functions. the other is type
	families.
\end{alist}

\begin{haskell}{}
--type level function
class And b1 b2 b | b 1 b 2 -> b where
    and :: b 1 -> b 2 -> b

instance And True True True    where and undefined
instance And True False False  where and undefined
instance And False True False  where and undefined
instance And False False False where and undefined
\end{haskell}

\part{Literals}
\chapter{OverloadedStrings}

\part{Constraints}
\part{Type signatures}
\part{Bindings and generalisation}
\part{Template Haskell}

\chapter{QuasiQuotes}
Quasi-quotation allows patterns and expressions to be written using
programmer-defined concrete syntax

\begin{definition}{Concrete Syntax}{}
	Concrete syntax refers to the actual textual representation of code, as
	opposed to abstract syntax trees.
	\begin{center}
		\begin{tabular}{ll}
			\toprule
			syntax type & form  \\
			\midrule
			concrete    & text  \\
			abstract    & trees \\
			\bottomrule
		\end{tabular}
	\end{center}
\end{definition}

\url{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/template_haskell.html#template-haskell-quasi-quotation}

\part{Bang patterns and Strict Haskell}
\part{Parallel and Concurrent}
\part{Unboxed types and primitive operations}
\part{Foreign function interface (FFI)}
\part{Safe Haskell}
\part{Miscellaneous}




\end{document}
